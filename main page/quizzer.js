// Quizzer.js

// Wait until DOM is fully loaded
window.addEventListener('DOMContentLoaded', () => {
    let currentDifficulty = "easy";
    // ---------- Helpers ----------
    function randomInt(max) {
        return Math.floor(Math.random() * max) + 1;
    }

    function randomIntRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function digitLength(n) {
        n = Math.abs(Number(n)) || 0;
        if (n === 0) return 1;
        return Math.floor(Math.log10(n)) + 1;
    }

    function safeEval(expr) {
        // expr is generated by us and uses only numbers and operators + - * / and parentheses
        // replace any unicode × ÷ to JS ops just in case
        const jsExpr = expr.replace(/×/g, '*').replace(/÷/g, '/');
        return Function(`"use strict"; return (${jsExpr});`)();
    }

    // Round to n decimal places, return number
    function roundToDecimals(value, decimals) {
        const p = Math.pow(10, decimals);
        return Math.round(value * p) / p;
    }

    // Determine if number is terminating decimal for a given max decimals
    // returns true if value * 10^maxDecimals is (nearly) integer
    function isTerminating(value, maxDecimals = 8) {
        if (!isFinite(value)) return true;
        const p = Math.pow(10, maxDecimals);
        return Math.abs(Math.round(value * p) - value * p) < 1e-9;
    }

    // Normalize display string (trim trailing zeros)
    function formatDisplay(val) {
        if (!isFinite(val)) return String(val);
        if (Math.abs(Math.round(val) - val) < 1e-9) return String(Math.round(val));
        // Show up to 8 decimals but trim trailing zeros
        let s = val.toFixed(8).replace(/\.?0+$/, '');
        return s;
    }

    // Check correctness with rounding rules:
    // - If exact integer expected => strict
    // - If non-terminating decimal => round true answer to 4 d.p. and accept within tolerance
    // - Otherwise accept within a small tolerance
    function isCorrectAnswer(trueVal, userVal) {
        if (typeof trueVal !== 'number' || typeof userVal !== 'number' || !isFinite(trueVal) || !isFinite(userVal)) return false;

        // If trueVal is integer (or extremely close)
        if (Math.abs(trueVal - Math.round(trueVal)) < 1e-9) {
            return Math.abs(userVal - Math.round(trueVal)) <= 1e-9;
        }

        // If terminating within 8 decimals, accept near exact up to 6 decimals
        if (isTerminating(trueVal, 8)) {
            // allow small FP noise
            return Math.abs(userVal - trueVal) <= 1e-6;
        }

        // Non-terminating: round true value to 4 decimal places and accept small tolerance
        const rounded4 = roundToDecimals(trueVal, 4);
        const tol = 0.0006; // fair tolerance (~half of 0.001)
        return Math.abs(userVal - rounded4) <= tol;
    }

    // ---------- Ratio adjustment functions ----------
    // Medium ratios:
    // - 3-digit * 1-digit
    // - 4-digit * 2-digit
    // Apply similar for division (make divisor small)
    function adjustMediumMultiplicative(a, b, op) {
        // only apply for × and ÷
        if (op !== '×' && op !== '÷') return [a, b];

        const la = digitLength(a);
        const lb = digitLength(b);

        // If one operand is 3-digit, make the other 1-digit
        if (la === 3 && lb !== 1) {
            b = randomInt(9);
        } else if (lb === 3 && la !== 1) {
            a = randomInt(9);
        }

        // If one operand is 4-digit, make the other 2-digit
        if (la === 4 && lb !== 2) {
            b = randomIntRange(10, 99);
        } else if (lb === 4 && la !== 2) {
            a = randomIntRange(10, 99);
        }

        // For division ensure divisor != 0
        if (op === '÷') {
            if (b === 0) b = 1;
        }

        return [a, b];
    }

    // Hard ratios:
    // - 5-digit × 2-digit, 4-digit × 2-digit, 3-digit × 1-digit
    // Apply same for division (keep divisor small)
    function adjustHardMultiplicative(a, b, op) {
        const la = digitLength(a);
        const lb = digitLength(b);

        // 5-digit -> pair with 2-digit
        if (la >= 5 && lb !== 2) {
            b = randomIntRange(10, 99);
        } else if (lb >= 5 && la !== 2) {
            a = randomIntRange(10, 99);
        }

        // 4-digit -> pair with 2-digit
        if (la === 4 && lb !== 2) {
            b = randomIntRange(10, 99);
        } else if (lb === 4 && la !== 2) {
            a = randomIntRange(10, 99);
        }

        // 3-digit -> pair with 1-digit
        if (la === 3 && lb !== 1) {
            b = randomInt(9);
        } else if (lb === 3 && la !== 1) {
            a = randomInt(9);
        }

        if (op === '÷') {
            if (b === 0) b = 1;
        }

        return [a, b];
    }

    // ---------- Quiz state & DOM ----------
    let totalQuestions = 0;
    let correctAnswers = 0;

    const questionEl = document.getElementById('question');
    const answerEl = document.getElementById('answer');
    const submitBtn = document.getElementById('submit');
    const skipBtn = document.getElementById('skip');
    const exitBtn = document.getElementById('exit');
    const feedbackEl = document.getElementById('feedback');
    const scoreEl = document.getElementById('score');
    const historyListEl = document.getElementById('historyList');
    const finalSummaryEl = document.getElementById('finalSummary');

    let currentQ = {};

    // Sounds
    const correctSound = new Audio('/assets/correct.mp3');
    const wrongSound = new Audio('/assets/error.mp3');
    const skipSound = new Audio('/assets/skip.mp3');
    const exitSound = new Audio('/assets/exit.wav');

    // ---------- Question generation ----------
    // Build a medium single-op expression (applies medium ratio rules)
    function generateMediumSingleOp() {
        // allow 2-4 digit numbers but we will apply ratio rules
        // generate lengths by picking ranges so we can hit 3-4 digit cases
        let a = randomIntRange(1, 9999); // 1..9999
        let b = randomIntRange(0, 9999); // allow 0 for subtraction but avoid for division later
        const ops = ['+', '-', '×', '÷'];
        const op = ops[randomInt(4) - 1];

        // Apply ratio rules if op is × or ÷
        [a, b] = adjustMediumMultiplicative(a, b, op);

        // avoid divisor zero
        if (op === '÷' && b === 0) b = 1;

        const exprDisplay = `${a} ${op} ${b}`;
        const jsExpr = exprDisplay.replace(/×/g, '*').replace(/÷/g, '/');
        let answer;
        try {
            answer = safeEval(jsExpr);
        } catch (e) {
            // fallback to easy
            return generateEasyQuestion();
        }

        return { questionText: exprDisplay, answer };
    }

    // Easy generator (your original behaviour)
    function generateEasyQuestion() {
        const opIndex = randomInt(4); // 1..4
        let a = randomInt(10);
        let b = randomInt(10);

        // Ensure no negative subtraction
        if (opIndex === 2 && a < b) [a, b] = [b, a];

        // Ensure clean division
        if (opIndex === 4) {
            // avoid zero
            if (b === 0) b = 1;
            a = a * b; // makes a divisible by b
        }

        let questionText, answer;
        switch (opIndex) {
            case 1: questionText = `${a} + ${b}`; answer = a + b; break;
            case 2: questionText = `${a} - ${b}`; answer = a - b; break;
            case 3: questionText = `${a} × ${b}`; answer = a * b; break;
            case 4: questionText = `${a} ÷ ${b}`; answer = a / b; break;
        }

        return { questionText, answer };
    }

    // Hard arithmetic generator: 2-4 terms, proper operators, parentheses, ratio rules
    function generateHardArithmetic() {
        const opsPool = ['+', '-', '×', '÷'];
        const termCount = randomIntRange(2, 4); // 2..4 terms
        const pieces = [];

        // We'll construct pieces like "(a op b)" then join them with outer operators
        for (let i = 0; i < termCount; i++) {
            // pick base sizes: a up to 5 digits, b up to 5 digits (we'll adjust)
            let a = randomIntRange(1, 99999);
            let b = randomIntRange(1, 99999);
            // pick op inside piece (to apply multiplicative ratio accordingly)
            let innerOp = opsPool[randomInt(4) - 1];

            // apply hard ratio for × and ÷ inside each piece
            if (innerOp === '×' || innerOp === '÷') {
                [a, b] = adjustHardMultiplicative(a, b, innerOp);
            } else {
                // for + and - we can allow any sizes but keep numbers reasonable
                // no change needed
            }

            // ensure divisor not zero
            if (innerOp === '÷' && b === 0) b = 1;

            let piece = `(${a} ${innerOp} ${b})`;
            pieces.push(piece);
        }

        // Join pieces with randomly chosen outer operators (also ensure proper operators between pieces)
        let expression = pieces[0];
        for (let i = 1; i < pieces.length; i++) {
            const outerOp = opsPool[randomInt(4) - 1];
            expression = `${expression} ${outerOp} ${pieces[i]}`;
        }

        // Randomly add parentheses grouping (wrap a subrange) ~50% chance
        if (randomInt(100) <= 50 && pieces.length >= 2) {
            // pick start and end piece indices
            const startPiece = randomIntRange(0, pieces.length - 2);
            const endPiece = randomIntRange(startPiece + 1, pieces.length - 1);

            // convert expression into tokens (pieces and outer ops)
            // We'll rebuild expression with grouping
            const tokens = [];
            for (let i = 0; i < pieces.length; i++) {
                tokens.push(pieces[i]);
                if (i < pieces.length - 1) {
                    // pick the operator that was originally between them from our earlier join
                    // To preserve original operators we rebuild from the previous expression string:
                    // Simpler: randomly choose an operator for each gap again (doesn't break rules)
                    tokens.push(['+', '-', '×', '÷'][randomInt(4) - 1]);
                }
            }

            // compute token positions and insert parentheses around the chosen piece-range
            const tokenStart = startPiece * 2;
            const tokenEnd = endPiece * 2;
            tokens[tokenStart] = '(' + tokens[tokenStart];
            tokens[tokenEnd] = tokens[tokenEnd] + ')';

            expression = tokens.join(' ');
        }

        // Evaluate answer
        const jsExpr = expression.replace(/×/g, '*').replace(/÷/g, '/');
        let answer;
        try {
            answer = safeEval(jsExpr);
        } catch (e) {
            // fallback to medium single op
            return generateMediumSingleOp();
        }

        return { questionText: expression, answer };
    }

    // Hard generator: either percentage or arithmetic
    function generateHardQuestion() {
        // 30% chance of percentage (tunable)
        if (Math.random() < 0.30) {
            const Y = randomIntRange(2, 99999);
            const X = randomIntRange(1, Y); // X <= Y to make percentages <= 100
            const questionText = `The percentage of ${X} bananas out of ${Y}`;
            const answer = (X / Y) * 100;
            return { questionText, answer };
        }

        // otherwise arithmetic
        return generateHardArithmetic();
    }

    // Master dispatcher
    function generateQuestion() {
        // Always re-read difficulty in case UI changed it
        const selectedDifficulty = localStorage.getItem('difficulty') || 'easy';

        // try generating a valid numeric answer
        for (let attempt = 0; attempt < 8; attempt++) {
            let q;
            if (selectedDifficulty === 'easy') q = generateEasyQuestion();
            else if (selectedDifficulty === 'medium') {
                // mix medium single-op or occasionally a two-op simple BODMAS
                if (Math.random() < 0.7) q = generateMediumSingleOp();
                else {
                    // two-op medium expression (no parentheses)
                    // make two operations but apply ratio rules to multiplicative/division ones
                    let a = randomIntRange(1, 9999);
                    let b = randomIntRange(0, 9999);
                    let c = randomIntRange(0, 9999);
                    const ops = ['+', '-', '×', '÷'];
                    const op1 = ops[randomInt(4) - 1];
                    const op2 = ops[randomInt(4) - 1];

                    // apply ratio to any × or ÷
                    if (op1 === '×' || op1 === '÷') [a, b] = adjustMediumMultiplicative(a, b, op1);
                    if (op2 === '×' || op2 === '÷') [b, c] = adjustMediumMultiplicative(b, c, op2);

                    if (op1 === '÷' && b === 0) b = 1;
                    if (op2 === '÷' && c === 0) c = 1;

                    const expr = `${a} ${op1} ${b} ${op2} ${c}`;
                    const jsExpr = expr.replace(/×/g, '*').replace(/÷/g, '/');
                    try {
                        const ans = safeEval(jsExpr);
                        q = { questionText: expr, answer: ans };
                    } catch (e) {
                        q = generateMediumSingleOp();
                    }
                }
            } else if (selectedDifficulty === 'hard') {
                q = generateHardQuestion();
            } else {
                q = generateEasyQuestion();
            }

            // ensure finite numeric answer
            if (q && typeof q.answer === 'number' && isFinite(q.answer)) return q;
            // otherwise try again
        }

        // final fallback
        return generateEasyQuestion();
    }

    // ---------- UI / Quiz flow ----------
    function updateScore() {
        scoreEl.textContent = correctAnswers;
    }

    // History format: "{Question} | Correct: {CorrectAnswer} | Yours: {UserAnswer}"
    function updateHistory(question, correctAnswer, userAnswer) {
        const li = document.createElement('li');
        const correctStr = formatDisplay(correctAnswer);
        const userStr = (userAnswer === null || userAnswer === undefined) ? '-' : formatDisplay(userAnswer);
        li.textContent = `${question} | Correct: ${correctStr} | Yours: ${userStr}`;
        // add classes to style (correct/wrong/skip)
        if (Math.abs(Number(userStr) - Number(correctStr)) <= 1e-9) {
            li.className = 'correct';
        } else {
            li.className = 'wrong';
        }
        historyListEl.prepend(li);
    }

    function updateFinalSummary() {
        if (totalQuestions > 0) {
            const percent = Math.round((correctAnswers / totalQuestions) * 100);
            finalSummaryEl.textContent =
                `${correctAnswers} out of ${totalQuestions} questions correct (${percent}%). Thanks for playing!`;
        }
    }

    function nextQuestion() {
        currentQ = generateQuestion();

        // prepare displayed text: percentage questions are phrases already
        const displayText = (typeof currentQ.questionText === 'string') ? currentQ.questionText : String(currentQ.questionText);
        questionEl.textContent = (displayText.toLowerCase().startsWith('the percentage')) ? displayText : `Solve: ${displayText}`;
        answerEl.value = '';
        answerEl.disabled = false;
        submitBtn.disabled = false;
        skipBtn.disabled = false;

        // clear feedback shortly after
        setTimeout(() => { feedbackEl.textContent = ''; }, 2500);
    }

    function submitAnswer() {
        const raw = answerEl.value.trim();
        if (raw === '') {
            feedbackEl.textContent = "Please enter a number!";
            feedbackEl.style.color = "#ffcccc";
            return;
        }

        // Parse numeric user answer - accept trailing % or plain numbers
        let userNum = Number(raw.replace('%', '').trim());
        if (Number.isNaN(userNum)) {
            feedbackEl.textContent = "Invalid number!";
            feedbackEl.style.color = "#ff4c4c";
            return;
        }

        // Prepare the true answer and the value to check against
        let trueAnswer = currentQ.answer;

        // If the question is percentage phrase, trueAnswer is in percent (we already set it as (X/Y)*100)
        // For checking we use numeric values directly.

        // If the true answer is non-terminating (detected by isTerminating), we round to 4 d.p.
        let checkValue = trueAnswer;
        if (!isTerminating(trueAnswer, 8)) {
            checkValue = roundToDecimals(trueAnswer, 4);
        }

        const correct = isCorrectAnswer(trueAnswer, userNum);

        if (correct) {
            correctAnswers++;
            feedbackEl.textContent = "Correct! ✅";
            feedbackEl.style.color = "#00ff88";
            try { correctSound.play(); } catch (e) { /* ignore */ }
        } else {
            feedbackEl.textContent = `Wrong ❌ (Correct: ${formatDisplay(checkValue)})`;
            feedbackEl.style.color = "#ff4c4c";
            try { wrongSound.play(); } catch (e) { /* ignore */ }
        }

        totalQuestions++;
        updateScore();
        // Save to history: show full details
        // If we rounded the true answer for display, show that rounded value
        const displayTrue = (!isTerminating(trueAnswer, 8)) ? roundToDecimals(trueAnswer, 4) : trueAnswer;
        updateHistory(currentQ.questionText, displayTrue, userNum);

        // small delay then next
        setTimeout(() => { nextQuestion(); }, 900);
    }

    function skipQuestion() {
        totalQuestions++;
        const trueAnswer = currentQ.answer;
        const displayTrue = (!isTerminating(trueAnswer, 8)) ? roundToDecimals(trueAnswer, 4) : trueAnswer;
        updateHistory(currentQ.questionText, displayTrue, null);
        feedbackEl.textContent = `Skipped ⏭️ Correct answer: ${formatDisplay(displayTrue)}`;
        feedbackEl.style.color = "#ffd700";
        try { skipSound.play(); } catch (e) { /* ignore */ }

        setTimeout(() => { nextQuestion(); }, 900);
    }

    function exitQuiz() {
        try { exitSound.play(); } catch (e) { /* ignore */ }
        answerEl.disabled = true;
        submitBtn.disabled = true;
        skipBtn.disabled = true;
        exitBtn.disabled = true;
        feedbackEl.textContent = "Quiz Ended!";
        updateFinalSummary();
    }

    // ---------- Event listeners ----------
    submitBtn.addEventListener('click', submitAnswer);
    skipBtn.addEventListener('click', skipQuestion);
    exitBtn.addEventListener('click', exitQuiz);

    answerEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') submitAnswer();
    });

    // Initialize
    updateScore();
    nextQuestion();

});
